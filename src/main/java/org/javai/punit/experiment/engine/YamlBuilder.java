package org.javai.punit.experiment.engine;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.Yaml;

/**
 * A fluent builder for constructing YAML documents with proper formatting.
 *
 * <p>This builder provides a high-level API that separates YAML structure concerns
 * from business logic. It handles:
 * <ul>
 *   <li>Proper indentation and formatting</li>
 *   <li>String quoting and escaping</li>
 *   <li>Block scalars for multiline strings</li>
 *   <li>Comment preservation</li>
 *   <li>Number formatting</li>
 * </ul>
 *
 * <p>Example usage:
 * <pre>{@code
 * String yaml = YamlBuilder.create()
 *     .comment("Generated by punit")
 *     .field("schemaVersion", "punit-spec-1")
 *     .field("useCaseId", "shopping.search")
 *     .startObject("statistics")
 *         .field("observed", 0.951, "%.4f")
 *         .field("standardError", 0.0068, "%.4f")
 *     .endObject()
 *     .build();
 * }</pre>
 */
public class YamlBuilder {

    private final StringBuilder comments = new StringBuilder();
    private final Map<String, Object> root = new LinkedHashMap<>();
    private final Deque<Object> contextStack = new ArrayDeque<>();
    private final Deque<String> keyStack = new ArrayDeque<>();

    private final DumperOptions options;
    private final Yaml yaml;

    private YamlBuilder() {
        this.options = new DumperOptions();
        options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);
        options.setPrettyFlow(true);
        options.setIndent(2);
        options.setWidth(120);
        this.yaml = new Yaml(options);
        contextStack.push(root);
    }

    /**
     * Creates a new YamlBuilder instance.
     *
     * @return a new builder
     */
    public static YamlBuilder create() {
        return new YamlBuilder();
    }

    /**
     * Adds a comment line to the document header.
     *
     * <p>Comments are prepended to the final YAML output.
     *
     * @param text the comment text (without leading #)
     * @return this builder
     */
    public YamlBuilder comment(String text) {
        comments.append("# ").append(text).append("\n");
        return this;
    }

    /**
     * Adds an empty line to the comments section.
     *
     * @return this builder
     */
    public YamlBuilder blankLine() {
        comments.append("\n");
        return this;
    }

    /**
     * Adds a field with a string value.
     *
     * @param key the field name
     * @param value the string value
     * @return this builder
     */
    public YamlBuilder field(String key, String value) {
        currentMap().put(key, value);
        return this;
    }

    /**
     * Adds a field with an integer value.
     *
     * @param key the field name
     * @param value the integer value
     * @return this builder
     */
    public YamlBuilder field(String key, int value) {
        currentMap().put(key, value);
        return this;
    }

    /**
     * Adds a field with a long value.
     *
     * @param key the field name
     * @param value the long value
     * @return this builder
     */
    public YamlBuilder field(String key, long value) {
        currentMap().put(key, value);
        return this;
    }

    /**
     * Adds a field with a double value, formatted according to the pattern.
     *
     * @param key the field name
     * @param value the double value
     * @param format the format pattern (e.g., "%.4f")
     * @return this builder
     */
    public YamlBuilder field(String key, double value, String format) {
        currentMap().put(key, new FormattedDouble(value, format));
        return this;
    }

    /**
     * Adds a field with a double value using default formatting.
     *
     * @param key the field name
     * @param value the double value
     * @return this builder
     */
    public YamlBuilder field(String key, double value) {
        currentMap().put(key, value);
        return this;
    }

    /**
     * Adds a field with a boolean value.
     *
     * @param key the field name
     * @param value the boolean value
     * @return this builder
     */
    public YamlBuilder field(String key, boolean value) {
        currentMap().put(key, value);
        return this;
    }

    /**
     * Adds a field with an object value.
     *
     * @param key the field name
     * @param value the value (can be null)
     * @return this builder
     */
    public YamlBuilder field(String key, Object value) {
        currentMap().put(key, value);
        return this;
    }

    /**
     * Conditionally adds a field only if the value is not null.
     *
     * @param key the field name
     * @param value the value (may be null)
     * @return this builder
     */
    public YamlBuilder fieldIfPresent(String key, Object value) {
        if (value != null) {
            currentMap().put(key, value);
        }
        return this;
    }

    /**
     * Conditionally adds a field only if the string is not null and not empty.
     *
     * @param key the field name
     * @param value the string value
     * @return this builder
     */
    public YamlBuilder fieldIfNotEmpty(String key, String value) {
        if (value != null && !value.isEmpty()) {
            currentMap().put(key, value);
        }
        return this;
    }

    /**
     * Adds a field with an inline array value, formatted as [a, b, c].
     *
     * @param key the field name
     * @param values the array values
     * @return this builder
     */
    public YamlBuilder inlineArray(String key, Object... values) {
        currentMap().put(key, new InlineArray(List.of(values)));
        return this;
    }

    /**
     * Adds a field with a formatted inline array (e.g., for confidence intervals).
     *
     * @param key the field name
     * @param format the format pattern for each value
     * @param values the array values
     * @return this builder
     */
    public YamlBuilder formattedInlineArray(String key, String format, double... values) {
        Object[] formatted = new Object[values.length];
        for (int i = 0; i < values.length; i++) {
            formatted[i] = new FormattedDouble(values[i], format);
        }
        currentMap().put(key, new InlineArray(List.of(formatted)));
        return this;
    }

    /**
     * Starts a nested object (map).
     *
     * @param key the object key
     * @return this builder
     */
    public YamlBuilder startObject(String key) {
        Map<String, Object> nested = new LinkedHashMap<>();
        currentMap().put(key, nested);
        contextStack.push(nested);
        keyStack.push(key);
        return this;
    }

    /**
     * Ends the current nested object.
     *
     * @return this builder
     * @throws IllegalStateException if not currently in an object context
     */
    public YamlBuilder endObject() {
        if (contextStack.size() <= 1) {
            throw new IllegalStateException("Cannot end object: not in nested context");
        }
        contextStack.pop();
        keyStack.pop();
        return this;
    }

    /**
     * Starts a list under the given key.
     *
     * @param key the list key
     * @return this builder
     */
    public YamlBuilder startList(String key) {
        java.util.List<Object> list = new java.util.ArrayList<>();
        currentMap().put(key, list);
        contextStack.push(list);
        keyStack.push(key);
        return this;
    }

    /**
     * Ends the current list.
     *
     * @return this builder
     * @throws IllegalStateException if not currently in a list context
     */
    public YamlBuilder endList() {
        if (contextStack.size() <= 1) {
            throw new IllegalStateException("Cannot end list: not in list context");
        }
        contextStack.pop();
        keyStack.pop();
        return this;
    }

    /**
     * Adds an item to the current list.
     *
     * @param value the item value
     * @return this builder
     * @throws IllegalStateException if not currently in a list context
     */
    @SuppressWarnings("unchecked")
    public YamlBuilder listItem(Object value) {
        Object current = contextStack.peek();
        if (!(current instanceof java.util.List)) {
            throw new IllegalStateException("Cannot add list item: not in list context");
        }
        ((java.util.List<Object>) current).add(value);
        return this;
    }

    /**
     * Adds a map item to the current list and enters that map context.
     *
     * @return this builder
     * @throws IllegalStateException if not currently in a list context
     */
    @SuppressWarnings("unchecked")
    public YamlBuilder startListItem() {
        Object current = contextStack.peek();
        if (!(current instanceof java.util.List)) {
            throw new IllegalStateException("Cannot add list item: not in list context");
        }
        Map<String, Object> item = new LinkedHashMap<>();
        ((java.util.List<Object>) current).add(item);
        contextStack.push(item);
        keyStack.push("[item]");
        return this;
    }

    /**
     * Ends the current list item (map within a list).
     *
     * @return this builder
     */
    public YamlBuilder endListItem() {
        if (contextStack.size() <= 1) {
            throw new IllegalStateException("Cannot end list item: not in nested context");
        }
        contextStack.pop();
        keyStack.pop();
        return this;
    }

    /**
     * Adds a field to the root level with a pre-built map.
     *
     * @param key the field name
     * @param map the map to add
     * @return this builder
     */
    public YamlBuilder objectField(String key, Map<String, Object> map) {
        currentMap().put(key, map);
        return this;
    }

    /**
     * Adds a multiline string as a block scalar.
     *
     * @param key the field name
     * @param text the multiline text
     * @return this builder
     */
    public YamlBuilder blockScalar(String key, String text) {
        currentMap().put(key, new BlockScalar(text));
        return this;
    }

    /**
     * Builds the final YAML string.
     *
     * @return the complete YAML document
     */
    public String build() {
        StringBuilder result = new StringBuilder();

        // Prepend comments
        if (comments.length() > 0) {
            result.append(comments);
            if (!comments.toString().endsWith("\n\n")) {
                result.append("\n");
            }
        }

        // Serialize the document
        result.append(serializeMap(root, 0));

        return result.toString();
    }

    @SuppressWarnings("unchecked")
    private Map<String, Object> currentMap() {
        Object current = contextStack.peek();
        if (current instanceof Map) {
            return (Map<String, Object>) current;
        }
        throw new IllegalStateException("Current context is not a map");
    }

    private String serializeMap(Map<String, Object> map, int indent) {
        StringBuilder sb = new StringBuilder();
        String prefix = "  ".repeat(indent);

        for (Map.Entry<String, Object> entry : map.entrySet()) {
            String key = entry.getKey();
            Object value = entry.getValue();

            sb.append(prefix).append(key).append(":");
            appendValue(sb, value, indent, key);
        }

        return sb.toString();
    }

    @SuppressWarnings("unchecked")
    private void appendValue(StringBuilder sb, Object value, int indent, String key) {
        String nextPrefix = "  ".repeat(indent + 1);

        if (value == null) {
            sb.append(" null\n");
        } else if (value instanceof FormattedDouble fd) {
            sb.append(" ").append(String.format(fd.format, fd.value)).append("\n");
        } else if (value instanceof InlineArray ia) {
            sb.append(" [");
            for (int i = 0; i < ia.values.size(); i++) {
                if (i > 0) sb.append(", ");
                Object item = ia.values.get(i);
                if (item instanceof FormattedDouble fd) {
                    sb.append(String.format(fd.format, fd.value));
                } else {
                    sb.append(item);
                }
            }
            sb.append("]\n");
        } else if (value instanceof BlockScalar bs) {
            sb.append(" |\n");
            for (String line : bs.text.split("\n", -1)) {
                sb.append(nextPrefix).append(line).append("\n");
            }
        } else if (value instanceof Map) {
            sb.append("\n");
            sb.append(serializeMap((Map<String, Object>) value, indent + 1));
        } else if (value instanceof java.util.List<?> list) {
            sb.append("\n");
            for (Object item : list) {
                if (item instanceof Map) {
                    sb.append(nextPrefix).append("-");
                    // For map items in a list, serialize inline with the dash
                    Map<String, Object> mapItem = (Map<String, Object>) item;
                    boolean first = true;
                    for (Map.Entry<String, Object> e : mapItem.entrySet()) {
                        if (first) {
                            sb.append(" ").append(e.getKey()).append(":");
                            appendValue(sb, e.getValue(), indent + 2, e.getKey());
                            first = false;
                        } else {
                            sb.append("  ".repeat(indent + 2)).append(e.getKey()).append(":");
                            appendValue(sb, e.getValue(), indent + 2, e.getKey());
                        }
                    }
                } else {
                    sb.append(nextPrefix).append("- ");
                    appendScalar(sb, item);
                    sb.append("\n");
                }
            }
        } else if (value instanceof String s) {
            sb.append(" ");
            appendScalar(sb, s);
            sb.append("\n");
        } else {
            sb.append(" ").append(value).append("\n");
        }
    }

    private void appendScalar(StringBuilder sb, Object value) {
        if (value instanceof String s) {
            if (needsQuoting(s)) {
                sb.append("\"").append(escapeString(s)).append("\"");
            } else {
                sb.append(s);
            }
        } else if (value instanceof FormattedDouble fd) {
            sb.append(String.format(fd.format, fd.value));
        } else {
            sb.append(value);
        }
    }

    private boolean needsQuoting(String str) {
        if (str.isEmpty()) return true;
        // Only quote if colon is followed by space (YAML indicator)
        // Standalone colons (like in timestamps 10:30:00) are safe
        if (str.contains(": ") || str.contains("#") || str.contains("\"") ||
            str.contains("'") || str.contains("\n") || str.contains("\r") ||
            str.contains("[") || str.contains("]") || str.contains("{") ||
            str.contains("}") || str.contains(",")) {
            return true;
        }
        // Check for YAML special values
        String lower = str.toLowerCase();
        return lower.equals("true") || lower.equals("false") ||
               lower.equals("null") || lower.equals("yes") || lower.equals("no");
    }

    private String escapeString(String str) {
        return str.replace("\\", "\\\\")
                  .replace("\"", "\\\"")
                  .replace("\n", "\\n")
                  .replace("\r", "\\r")
                  .replace("\t", "\\t");
    }

    // Helper classes for special value types

    private record FormattedDouble(double value, String format) {}

    private record InlineArray(List<Object> values) {}

    private record BlockScalar(String text) {}
}
